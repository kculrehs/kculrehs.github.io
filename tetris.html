<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111827;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#22c55e;
      --danger:#ef4444;
      --border: rgba(255,255,255,0.10);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      padding:16px;
      background: radial-gradient(1200px 800px at 50% 20%, #0f172a, var(--bg));
      color:var(--text);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    .wrap{width:min(980px,100%); display:grid; gap:12px;}
    header{
      display:flex; justify-content:space-between; align-items:baseline; gap:12px;
      padding:12px 14px; border:1px solid var(--border); border-radius:14px;
      background: rgba(17,24,39,0.75); backdrop-filter: blur(8px);
    }
    header h1{margin:0; font-size:18px;}
    .stats{display:flex; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:14px; justify-content:flex-end}
    .stats b{color:var(--text)}
    .panel{
      display:grid; gap:12px;
      padding:14px; border:1px solid var(--border); border-radius:14px;
      background: rgba(17,24,39,0.75); backdrop-filter: blur(8px);
    }
    .game{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 860px){
      .game{grid-template-columns: 1fr; }
      .side{display:grid; grid-template-columns: 1fr 1fr; gap:12px;}
      .lbBox{grid-column: 1 / -1;}
    }
    canvas{
      width:100%;
      height:auto;
      border-radius:12px;
      border:1px solid var(--border);
      background:#0b1220;
      display:block;
    }
    .box{
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      background: rgba(255,255,255,0.05);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between}
    .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button, select, input{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:14px;
      cursor:pointer;
      outline:none;
    }
    input{cursor:text; width:100%;}
    button:hover, select:hover, input:hover{border-color: rgba(255,255,255,0.22);}
    button.primary{border-color: rgba(34,197,94,0.35);}
    button.primary:hover{border-color: rgba(34,197,94,0.6);}
    button.danger{border-color: rgba(239,68,68,0.35);}
    button.danger:hover{border-color: rgba(239,68,68,0.6);}
    button:disabled{opacity:.55; cursor:not-allowed;}
    .hint{color:var(--muted); font-size:13px; line-height:1.35}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.14); background: rgba(0,0,0,0.25); color: var(--text);}
    .touch{
      display:none;
      gap:8px;
      justify-content:center;
      user-select:none; -webkit-user-select:none;
      touch-action: manipulation;
    }
    .touch button{width:64px; height:54px; font-size:16px; border-radius:14px;}
    .touch .col{display:grid; gap:8px;}
    @media (max-width: 680px){ .touch{display:flex;} }

    .mini{font-size:12px; color:var(--muted)}
    .pill{
      font-size:12px; padding:4px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      color: rgba(255,255,255,0.85);
      display:inline-flex; gap:8px; align-items:center;
    }
    .statusLine{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      margin-top:8px;
    }
    .lb{
      margin-top:10px;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:12px;
      overflow:hidden;
    }
    .lbHeader{
      display:flex; justify-content:space-between; align-items:center;
      padding:10px 12px;
      background: rgba(255,255,255,0.04);
      border-bottom:1px solid rgba(255,255,255,0.10);
    }
    .lbList{
      max-height: 360px;
      overflow:auto;
      background: rgba(0,0,0,0.14);
    }
    table{width:100%; border-collapse:collapse; font-size:13px;}
    th, td{padding:10px 12px; border-bottom:1px solid rgba(255,255,255,0.08); text-align:left;}
    th{position:sticky; top:0; background: rgba(15,23,42,0.95); z-index:2; font-weight:700;}
    tr.me{background: rgba(34,197,94,0.10);}
    .right{text-align:right;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üß± Classic Tetris</h1>
      <div class="stats">
        <div>Score: <b id="score">0</b></div>
        <div>Lines: <b id="lines">0</b></div>
        <div>Level: <b id="level">1</b></div>
        <div>Best: <b id="best">0</b></div>
      </div>
    </header>

    <div class="panel">
      <div class="game">
        <canvas id="board" width="480" height="720" aria-label="Tetris board"></canvas>

        <div class="side">
          <div class="box">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px;">
              <div style="font-weight:700;">Next</div>
              <label style="display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px;">
                Speed
                <select id="speed">
                  <option value="1">Normal</option>
                  <option value="1.35">Fast</option>
                  <option value="1.75">Insane</option>
                </select>
              </label>
            </div>
            <canvas id="next" width="240" height="240" aria-label="Next piece"></canvas>
          </div>

          <div class="box">
            <div class="row" style="margin-bottom:10px;">
              <div class="controls">
                <button class="primary" id="start">Start</button>
                <button id="pause">Pause</button>
                <button class="danger" id="reset">Reset</button>
              </div>
            </div>

            <div class="hint">
              Controls:<br>
              <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> move (hold to slide faster as level rises) ‚Ä¢
              <span class="kbd">‚Üì</span> soft drop (hold) ‚Ä¢ <span class="kbd">Space</span> hard drop<br>
              <span class="kbd">Z</span>/<span class="kbd">‚Üë</span> rotate ‚Ä¢ <span class="kbd">C</span> hold (optional) ‚Ä¢ <span class="kbd">P</span> pause
            </div>

            <div class="touch" style="margin-top:12px;">
              <div class="col">
                <button id="rotBtn">‚ü≥</button>
                <div style="display:flex; gap:8px; justify-content:center;">
                  <button id="leftBtn">‚óÄ</button>
                  <button id="downBtn">‚ñº</button>
                  <button id="rightBtn">‚ñ∂</button>
                </div>
                <div style="display:flex; gap:8px; justify-content:center;">
                  <button id="dropBtn">‚¨á‚¨á</button>
                  <button id="pauseBtn">‚èØ</button>
                </div>
              </div>
            </div>

            <div class="hint" style="margin-top:10px;">
              Tip: Clear lines to level up. Drop speed and movement speed increase each level.
              Game ends when the stack reaches the top.
            </div>
          </div>

          <!-- ACCOUNT + LEADERBOARD -->
          <div class="box lbBox">
            <div class="row">
              <div style="font-weight:800;">üèÜ Global Leaderboard</div>
              <span class="pill" id="authPill">Offline</span>
            </div>

            <div class="statusLine">
              <button class="primary" id="signInBtn">Sign in</button>
              <button id="signOutBtn" style="display:none;">Sign out</button>
            </div>

            <div style="margin-top:10px;">
              <div class="mini" style="margin-bottom:6px;">IGN (shown on leaderboard)</div>
              <div class="row" style="gap:10px; align-items:stretch;">
                <input id="ignInput" maxlength="18" placeholder="Enter IGN (ex: Redsun)" />
                <button id="saveIgnBtn">Save</button>
              </div>
              <div class="mini" id="whoami" style="margin-top:6px;"></div>
            </div>

            <div class="row" style="margin-top:10px;">
              <div class="mini" id="submitHint">Finish a game to submit your score.</div>
              <button class="primary" id="submitScoreBtn" disabled>Submit score</button>
            </div>

            <div class="lb">
              <div class="lbHeader">
                <div class="mini">Top 100</div>
                <div class="mini" id="lbStatus">Loading‚Ä¶</div>
              </div>
              <div class="lbList">
                <table>
                  <thead>
                    <tr>
                      <th style="width:64px;">#</th>
                      <th>IGN</th>
                      <th class="right">Score</th>
                    </tr>
                  </thead>
                  <tbody id="lbBody">
                    <tr><td colspan="3" class="mini">Loading leaderboard‚Ä¶</td></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div class="hint" style="margin-top:10px;">
              Note: You must be signed in and have an IGN to appear on the leaderboard.
              Only the top 100 scores are displayed.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  // ---------------------------
  // FIREBASE (Auth + Firestore)
  // ---------------------------
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, setDoc, serverTimestamp,
    collection, query, orderBy, limit, onSnapshot
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // 1) PASTE YOUR FIREBASE CONFIG HERE
  const firebaseConfig = {
    apiKey: "PASTE_API_KEY",
    authDomain: "PASTE_AUTH_DOMAIN",
    projectId: "PASTE_PROJECT_ID",
    storageBucket: "PASTE_STORAGE_BUCKET",
    messagingSenderId: "PASTE_SENDER_ID",
    appId: "PASTE_APP_ID",
  };

  // If config is not filled, we keep the game working but disable leaderboard.
  const firebaseReady = !Object.values(firebaseConfig).some(v => String(v).startsWith("PASTE_"));

  let app=null, auth=null, db=null, provider=null;
  if (firebaseReady) {
    app = initializeApp(firebaseConfig);
    auth = getAuth(app);
    db = getFirestore(app);
    provider = new GoogleAuthProvider();
  }

  // UI refs
  const authPill = document.getElementById("authPill");
  const signInBtn = document.getElementById("signInBtn");
  const signOutBtn = document.getElementById("signOutBtn");
  const ignInput = document.getElementById("ignInput");
  const saveIgnBtn = document.getElementById("saveIgnBtn");
  const whoami = document.getElementById("whoami");
  const submitScoreBtn = document.getElementById("submitScoreBtn");
  const submitHint = document.getElementById("submitHint");
  const lbStatus = document.getElementById("lbStatus");
  const lbBody = document.getElementById("lbBody");

  // auth state
  let currentUser = null;
  let currentIGN = "";
  let lastGameScore = 0;
  let lastGameOver = false;

  function sanitizeIGN(s){
    const cleaned = (s || "").trim().replace(/[^\w \-]/g, "").replace(/\s+/g, " ");
    if (cleaned.length < 2) return "";
    return cleaned.slice(0, 18);
  }

  function setAuthPill(text){
    authPill.textContent = text;
    authPill.style.borderColor = text.includes("Signed in") ? "rgba(34,197,94,0.35)" : "rgba(255,255,255,0.12)";
  }

  function setLeaderboardStatus(text){
    lbStatus.textContent = text;
  }

  function updateSubmitUI(){
    if (!firebaseReady){
      submitScoreBtn.disabled = true;
      submitHint.textContent = "Leaderboard disabled (Firebase config missing).";
      return;
    }
    if (!currentUser){
      submitScoreBtn.disabled = true;
      submitHint.textContent = "Sign in to submit your score.";
      return;
    }
    if (!currentIGN){
      submitScoreBtn.disabled = true;
      submitHint.textContent = "Set an IGN to submit your score.";
      return;
    }
    if (!lastGameOver){
      submitScoreBtn.disabled = true;
      submitHint.textContent = "Finish a game to submit your score.";
      return;
    }
    if (lastGameScore <= 0){
      submitScoreBtn.disabled = true;
      submitHint.textContent = "Score must be greater than 0 to submit.";
      return;
    }
    submitScoreBtn.disabled = false;
    submitHint.textContent = `Game over! Ready to submit: ${lastGameScore}`;
  }

  async function ensureUserDoc(uid, payload){
    const ref = doc(db, "users", uid);
    await setDoc(ref, payload, { merge: true });
  }

  async function saveIGN(){
    if (!firebaseReady) return alert("Firebase not configured yet.");
    if (!currentUser) return alert("Please sign in first.");
    const ign = sanitizeIGN(ignInput.value);
    if (!ign) return alert("IGN must be 2‚Äì18 characters (letters/numbers/space/_-).");
    currentIGN = ign;

    await ensureUserDoc(currentUser.uid, {
      ign,
      email: currentUser.email || "",
      updatedAt: serverTimestamp()
    });

    const scoreRef = doc(db, "scores", currentUser.uid);
    await setDoc(scoreRef, {
      uid: currentUser.uid,
      ign,
      updatedAt: serverTimestamp()
    }, { merge: true });

    renderWhoAmI();
    updateSubmitUI();
  }

  function renderWhoAmI(){
    if (!currentUser){
      whoami.textContent = "";
      return;
    }
    const email = currentUser.email ? ` ‚Ä¢ ${currentUser.email}` : "";
    whoami.textContent = `Signed in as ${currentIGN || "(no IGN yet)"}${email}`;
  }

  async function submitScore(score){
    if (!firebaseReady) return alert("Firebase not configured yet.");
    if (!currentUser) return alert("Please sign in first.");
    if (!currentIGN) return alert("Please set an IGN first.");
    if (!score || score <= 0) return alert("Score must be greater than 0.");

    const ref = doc(db, "scores", currentUser.uid);
    const snap = await getDoc(ref);
    const prev = snap.exists() ? (snap.data().score || 0) : 0;

    if (score <= prev){
      return alert(`Your saved best is ${prev}. Beat it to update the leaderboard.`);
    }

    await setDoc(ref, {
      uid: currentUser.uid,
      ign: currentIGN,
      score: score,
      updatedAt: serverTimestamp()
    }, { merge: true });

    alert("Score submitted! If it‚Äôs in the Top 100, it will show up.");
  }

  async function loadMyIGN(){
    if (!firebaseReady || !currentUser) return;
    const uref = doc(db, "users", currentUser.uid);
    const usnap = await getDoc(uref);
    const ign = usnap.exists() ? (usnap.data().ign || "") : "";
    currentIGN = ign;
    ignInput.value = ign || "";
    renderWhoAmI();
  }

  function renderLeaderboard(rows){
    lbBody.innerHTML = "";
    if (!rows.length){
      lbBody.innerHTML = `<tr><td colspan="3" class="mini">No scores yet.</td></tr>`;
      return;
    }
    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      const isMe = currentUser && r.uid === currentUser.uid;
      if (isMe) tr.classList.add("me");
      tr.innerHTML = `
        <td>${idx + 1}</td>
        <td>${(r.ign || "Unknown").toString().slice(0,18)}</td>
        <td class="right">${Number(r.score || 0).toLocaleString()}</td>
      `;
      lbBody.appendChild(tr);
    });
  }

  function startLeaderboardListener(){
    if (!firebaseReady){
      setLeaderboardStatus("Firebase not configured");
      lbBody.innerHTML = `<tr><td colspan="3" class="mini">Add Firebase config to enable leaderboard.</td></tr>`;
      return;
    }
    setLeaderboardStatus("Live");
    const qy = query(collection(db, "scores"), orderBy("score", "desc"), limit(100));
    onSnapshot(qy, (snap) => {
      const rows = [];
      snap.forEach(d => rows.push(d.data()));
      renderLeaderboard(rows);
    }, (err) => {
      console.error(err);
      setLeaderboardStatus("Error");
      lbBody.innerHTML = `<tr><td colspan="3" class="mini">Failed to load leaderboard.</td></tr>`;
    });
  }

  if (!firebaseReady){
    setAuthPill("Offline");
    signInBtn.disabled = true;
    saveIgnBtn.disabled = true;
    updateSubmitUI();
  } else {
    onAuthStateChanged(auth, async (user) => {
      currentUser = user || null;
      if (currentUser){
        setAuthPill("Signed in");
        signInBtn.style.display = "none";
        signOutBtn.style.display = "inline-block";
        await loadMyIGN();
      } else {
        setAuthPill("Offline");
        signInBtn.style.display = "inline-block";
        signOutBtn.style.display = "none";
        currentIGN = "";
        ignInput.value = "";
        whoami.textContent = "";
      }
      updateSubmitUI();
    });

    signInBtn.addEventListener("click", async () => {
      try{ await signInWithPopup(auth, provider); }
      catch(e){ console.error(e); alert("Sign-in failed. Enable Google sign-in + add your GitHub domain in Firebase Auth."); }
    });

    signOutBtn.addEventListener("click", async () => { await signOut(auth); });
    saveIgnBtn.addEventListener("click", saveIGN);
    submitScoreBtn.addEventListener("click", async () => { await submitScore(lastGameScore); updateSubmitUI(); });

    startLeaderboardListener();
  }

  // ---------------------------
  // TETRIS GAME (VISIBLE-SPAWN VERSION)
  // ---------------------------
  (() => {
    const COLS = 10;
    const ROWS = 20;
    const CELL = 36;

    const boardCanvas = document.getElementById("board");
    const ctx = boardCanvas.getContext("2d");
    const nextCanvas = document.getElementById("next");
    const nctx = nextCanvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const linesEl = document.getElementById("lines");
    const levelEl = document.getElementById("level");
    const bestEl  = document.getElementById("best");
    const speedSel = document.getElementById("speed");

    const startBtn = document.getElementById("start");
    const pauseBtn = document.getElementById("pause");
    const resetBtn = document.getElementById("reset");

    // Touch
    const rotBtn = document.getElementById("rotBtn");
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");
    const downBtn = document.getElementById("downBtn");
    const dropBtn = document.getElementById("dropBtn");
    const pauseBtn2 = document.getElementById("pauseBtn");

    boardCanvas.width = COLS * CELL;
    boardCanvas.height = ROWS * CELL;

    const COLORS = {
      I: "#60a5fa",
      O: "#fbbf24",
      T: "#a78bfa",
      S: "#34d399",
      Z: "#f87171",
      J: "#3b82f6",
      L: "#fb923c",
      G: "#0b1220"
    };

    const SHAPES = {
      I: [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0],
      ],
      O: [
        [1,1],
        [1,1],
      ],
      T: [
        [0,1,0],
        [1,1,1],
        [0,0,0],
      ],
      S: [
        [0,1,1],
        [1,1,0],
        [0,0,0],
      ],
      Z: [
        [1,1,0],
        [0,1,1],
        [0,0,0],
      ],
      J: [
        [1,0,0],
        [1,1,1],
        [0,0,0],
      ],
      L: [
        [0,0,1],
        [1,1,1],
        [0,0,0],
      ]
    };

    // State
    let grid, current, next, hold, holdUsed;
    let score = 0, lines = 0, level = 1, best = 0;
    let running = false, paused = false;
    let dropTimer = 0;
    let lastTime = 0;
    let speedMult = Number(speedSel.value);

    // Movement auto-repeat (DAS/ARR) ‚Äî faster per level
    let keyLeft = false, keyRight = false, keyDown = false;
    let moveDir = 0;
    let dasTimer = 0;
    let arrTimer = 0;
    let softDropTimer = 0;

    const clone = (m) => m.map(r => r.slice());
    const randBag = () => {
      const types = ["I","O","T","S","Z","J","L"];
      for (let i = types.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [types[i], types[j]] = [types[j], types[i]];
      }
      return types;
    };
    let bag = randBag();

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    function getDAS(){ return clamp(0.14 - (level - 1) * 0.004, 0.07, 0.14); }
    function getARR(){ return clamp(0.06 - (level - 1) * 0.002, 0.025, 0.06); }
    function getSoftDropInterval(){ return clamp(0.05 - (level - 1) * 0.0015, 0.018, 0.05); }

    function getBest() {
      const v = localStorage.getItem("tetris_best");
      best = v ? Number(v) : 0;
      bestEl.textContent = best;
    }
    function setBest() {
      localStorage.setItem("tetris_best", String(best));
      bestEl.textContent = best;
    }

    function emptyGrid() {
      const g = [];
      for (let r = 0; r < ROWS; r++) g.push(new Array(COLS).fill(null));
      return g;
    }

    // ‚úÖ SPAWN IN VISIBLE AREA (y=0)
    function newPiece(type) {
      const shape = clone(SHAPES[type]);
      const x = ((COLS / 2) | 0) - ((shape[0].length / 2) | 0);
      const y = 0;
      return { type, shape, x, y };
    }

    function pullFromBag() {
      if (bag.length === 0) bag = randBag();
      return bag.pop();
    }

    function updateHUD() {
      scoreEl.textContent = score;
      linesEl.textContent = lines;
      levelEl.textContent = level;
      bestEl.textContent = best;
    }

    function resetGame() {
      grid = emptyGrid();
      score = 0; lines = 0; level = 1;
      hold = null; holdUsed = false;
      bag = randBag();
      current = newPiece(pullFromBag());
      next = newPiece(pullFromBag());
      running = false;
      paused = false;
      dropTimer = 0;
      lastTime = performance.now();

      keyLeft = keyRight = keyDown = false;
      moveDir = 0; dasTimer = 0; arrTimer = 0; softDropTimer = 0;

      lastGameScore = 0;
      lastGameOver = false;
      updateSubmitUI();

      updateHUD();
      draw();
      drawNext();
      pauseBtn.textContent = "Pause";
    }

    function collide(piece) {
      const { shape, x, y } = piece;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const gx = x + c;
          const gy = y + r;

          if (gx < 0 || gx >= COLS) return true;
          if (gy < 0) return true;         // should never happen now, but safe
          if (gy >= ROWS) return true;
          if (grid[gy][gx]) return true;
        }
      }
      return false;
    }

    function merge(piece) {
      const { shape, x, y, type } = piece;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const gx = x + c;
          const gy = y + r;
          if (gy >= 0 && gy < ROWS) grid[gy][gx] = type;
        }
      }
    }

    function clearLines() {
      let cleared = 0;
      for (let r = 0; r < ROWS; r++) {
        if (grid[r].every(v => v !== null)) {
          grid.splice(r, 1);
          grid.unshift(new Array(COLS).fill(null));
          cleared++;
        }
      }
      if (cleared > 0) {
        const table = [0, 100, 300, 500, 800];
        score += table[cleared] * level;
        lines += cleared;

        const newLevel = 1 + Math.floor(lines / 10);
        if (newLevel !== level) level = newLevel;

        if (score > best) { best = score; setBest(); }
        updateHUD();
      }
    }

    function rotate(shape) {
      const N = shape.length;
      const M = shape[0].length;
      const out = Array.from({ length: M }, () => new Array(N).fill(0));
      for (let r = 0; r < N; r++) for (let c = 0; c < M; c++) out[c][N - 1 - r] = shape[r][c];
      return out;
    }

    function tryRotate() {
      const rotated = rotate(current.shape);
      const test = { ...current, shape: rotated };
      const kicks = [0, -1, 1, -2, 2];
      for (const k of kicks) {
        const cand = { ...test, x: test.x + k };
        if (!collide(cand)) { current = cand; return; }
      }
    }

    function move(dx, dy) {
      const test = { ...current, x: current.x + dx, y: current.y + dy };
      if (!collide(test)) { current = test; return true; }
      return false;
    }

    function hardDrop() {
      let dropped = 0;
      while (move(0, 1)) dropped++;
      score += dropped * 2;
      lock();
    }

    function softDrop() {
      if (move(0, 1)) {
        score += 1;
        updateHUD();
      } else {
        lock();
      }
    }

    // ‚úÖ GAME OVER when top row gets occupied
    function isStackOverflow() {
      for (let c = 0; c < COLS; c++) {
        if (grid[0][c] !== null) return true;
      }
      return false;
    }

    function gameOver() {
      running = false;
      paused = false;

      keyLeft = keyRight = keyDown = false;
      moveDir = 0; dasTimer = 0; arrTimer = 0; softDropTimer = 0;

      draw();
      overlay("Game Over", "Press Start or Reset");

      lastGameScore = score;
      lastGameOver = true;
      updateSubmitUI();
    }

    function lock() {
      merge(current);

      // check overflow immediately
      if (isStackOverflow()) {
        gameOver();
        return;
      }

      clearLines();
      holdUsed = false;

      current = next;
      next = newPiece(pullFromBag());
      drawNext();

      // spawn collision ends game
      if (collide(current)) gameOver();
    }

    function holdPiece() {
      if (!running || paused) return;
      if (holdUsed) return;
      holdUsed = true;

      const curType = current.type;
      if (!hold) {
        hold = curType;
        current = next;
        next = newPiece(pullFromBag());
        drawNext();
      } else {
        const swap = hold;
        hold = curType;
        current = newPiece(swap);
      }
      if (collide(current)) gameOver();
    }

    function overlay(title, subtitle) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 42px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(title, boardCanvas.width / 2, boardCanvas.height / 2 - 10);
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText(subtitle, boardCanvas.width / 2, boardCanvas.height / 2 + 22);
    }

    // ‚úÖ No hidden-row shift anymore
    function drawCell(x, y, color) {
      const s = CELL;
      const px = x * s;
      const py = y * s;

      ctx.fillStyle = color;
      ctx.fillRect(px + 1, py + 1, s - 2, s - 2);

      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(px + 3, py + 3, s - 6, s / 3);

      ctx.fillStyle = "rgba(0,0,0,0.20)";
      ctx.fillRect(px + 3, py + s - 10, s - 6, 7);
    }

    function drawGrid() {
      ctx.fillStyle = COLORS.G;
      ctx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);

      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      for (let x = 1; x < COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * CELL, 0);
        ctx.lineTo(x * CELL, boardCanvas.height);
        ctx.stroke();
      }
      for (let y = 1; y < ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * CELL);
        ctx.lineTo(boardCanvas.width, y * CELL);
        ctx.stroke();
      }
    }

    function drawGhost() {
      const ghost = { ...current, shape: current.shape.map(r => r.slice()) };
      while (!collide({ ...ghost, y: ghost.y + 1 })) ghost.y++;
      const { shape, x, y, type } = ghost;
      ctx.save();
      ctx.globalAlpha = 0.25;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const gx = x + c;
          const gy = y + r;
          if (gy >= 0) drawCell(gx, gy, COLORS[type]);
        }
      }
      ctx.restore();
    }

    function drawPiece(piece) {
      const { shape, x, y, type } = piece;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const gx = x + c;
          const gy = y + r;
          if (gy >= 0) drawCell(gx, gy, COLORS[type]);
        }
      }
    }

    function draw() {
      drawGrid();

      // placed blocks
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const v = grid[r][c];
          if (v) drawCell(c, r, COLORS[v]);
        }
      }

      if (running) drawGhost();
      drawPiece(current);

      if (running && paused) overlay("Paused", "Press P or Pause to resume");

      if (!running) {
        ctx.fillStyle = "rgba(255,255,255,0.80)";
        ctx.font = "16px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Press Start to play", boardCanvas.width / 2, 22);
      }
    }

    function drawNext() {
      nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
      nctx.fillStyle = "#0b1220";
      nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

      const s = 30;
      const shape = next.shape;
      const type = next.type;

      const w = shape[0].length;
      const h = shape.length;
      const ox = ((nextCanvas.width / s - w) / 2) | 0;
      const oy = ((nextCanvas.height / s - h) / 2) | 0;

      for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
          if (!shape[r][c]) continue;
          nctx.fillStyle = COLORS[type];
          nctx.fillRect((ox + c)*s + 1, (oy + r)*s + 1, s - 2, s - 2);
          nctx.fillStyle = "rgba(255,255,255,0.10)";
          nctx.fillRect((ox + c)*s + 3, (oy + r)*s + 3, s - 6, s/3);
        }
      }
    }

    function start() {
      if (!running) {
        running = true;
        paused = false;
        pauseBtn.textContent = "Pause";
        lastTime = performance.now();

        lastGameOver = false;
        lastGameScore = 0;
        updateSubmitUI();

        keyLeft = keyRight = keyDown = false;
        moveDir = 0; dasTimer = 0; arrTimer = 0; softDropTimer = 0;

        // If spawn collides, end immediately
        if (collide(current)) { gameOver(); return; }

        requestAnimationFrame(loop);
      } else if (paused) {
        togglePause();
      }
    }

    function togglePause() {
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
      draw();
    }

    function loop(t) {
      if (!running) return;

      const dt = (t - lastTime) / 1000;
      lastTime = t;

      if (!paused) {
        const base = Math.max(0.08, 0.75 - (level - 1) * 0.06);
        const interval = base / speedMult;

        // Horizontal DAS/ARR
        const wantDir = (keyRight ? 1 : 0) + (keyLeft ? -1 : 0);
        if (wantDir !== 0) {
          if (wantDir !== moveDir) {
            moveDir = wantDir;
            dasTimer = 0;
            arrTimer = 0;
            move(moveDir, 0);
          } else {
            dasTimer += dt;
            if (dasTimer >= getDAS()) {
              arrTimer += dt;
              const arr = getARR();
              while (arrTimer >= arr) {
                arrTimer -= arr;
                move(moveDir, 0);
              }
            }
          }
        } else {
          moveDir = 0;
          dasTimer = 0;
          arrTimer = 0;
        }

        // Hold Down Arrow = repeated soft drop
        if (keyDown) {
          softDropTimer += dt;
          const sdi = getSoftDropInterval();
          while (softDropTimer >= sdi) {
            softDropTimer -= sdi;
            softDrop();
            if (!running) break;
          }
        } else {
          softDropTimer = 0;
        }

        // Gravity
        dropTimer += dt;
        if (dropTimer >= interval) {
          dropTimer = 0;
          if (!move(0, 1)) lock();
        }

        draw();
      }

      requestAnimationFrame(loop);
    }

    // Keyboard
    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();

      if (k === "p") { togglePause(); return; }

      // Start with Start button only (no hidden/auto-start movement)
      if (!running) return;

      if (k === " "){
        e.preventDefault();
        if (!paused) hardDrop();
        draw();
        return;
      }
      if (paused) return;

      if (k === "arrowleft") keyLeft = true;
      else if (k === "arrowright") keyRight = true;
      else if (k === "arrowdown") keyDown = true;
      else if (k === "arrowup" || k === "z") tryRotate();
      else if (k === "c") holdPiece();

      draw();
    });

    document.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "arrowleft") keyLeft = false;
      else if (k === "arrowright") keyRight = false;
      else if (k === "arrowdown") keyDown = false;
    });

    // Buttons
    startBtn.addEventListener("click", () => { resetGame(); start(); });
    pauseBtn.addEventListener("click", togglePause);
    resetBtn.addEventListener("click", resetGame);

    speedSel.addEventListener("change", () => { speedMult = Number(speedSel.value); });

    // Touch taps
    const tap = (btn, fn) => btn && btn.addEventListener("click", () => {
      if (!running) return;
      if (paused) return;
      fn();
      draw();
    });

    tap(rotBtn, () => tryRotate());
    tap(leftBtn, () => move(-1,0));
    tap(rightBtn, () => move(1,0));
    tap(downBtn, () => softDrop());
    tap(dropBtn, () => hardDrop());
    tap(pauseBtn2, () => togglePause());

    // Init
    getBest();
    resetGame();
  })();
</script>
</body>
</html>

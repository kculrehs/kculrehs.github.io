<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Battleship (Fog of War • Touch • Smarter AI • Extra Turn on Hit)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --text:#e7ecff; --muted:#a9b2d6;
      --accent:#6aa9ff; --good:#39d98a; --bad:#ff5c7a; --warn:#ffd166;
      --grid:#2b3666; --water:#0f1a3f; --sunk:#ffb703;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(1200px 700px at 20% 10%, #17245a 0%, var(--bg) 55%);
      color:var(--text);
    }
    header{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      padding:14px 18px; border-bottom:1px solid #22306a; background:rgba(10,14,28,.6);
      backdrop-filter: blur(10px);
      position:sticky; top:0; z-index:10;
    }
    header h1{font-size:18px; margin:0; letter-spacing:.2px}
    .wrap{max-width:1150px; margin:0 auto; padding:16px}
    .row{display:flex; flex-wrap:wrap; gap:16px}
    .panel{
      background:linear-gradient(180deg, rgba(18,26,51,.96), rgba(14,20,41,.96));
      border:1px solid #22306a; border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.28);
      padding:14px;
    }
    .controls{flex: 1 1 380px; min-width:340px}
    .boards{flex: 2 1 650px; min-width:320px}
    .controls h2,.boards h2{font-size:14px; margin:0 0 10px 0; color:var(--muted); font-weight:700}
    .line{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0}
    button, select{
      background:#1a2552; color:var(--text); border:1px solid #2b3a85;
      padding:9px 11px; border-radius:10px; cursor:pointer;
      font-weight:700;
    }
    button:hover{border-color:#3f5dff}
    button:disabled{opacity:.55; cursor:not-allowed}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px; border:1px solid #2b3a85;
      background:rgba(26,37,82,.55); color:var(--muted); font-size:13px;
    }
    .pill strong{color:var(--text)}
    .status{
      margin-top:10px; padding:10px 12px; border-radius:12px;
      border:1px solid #2b3a85; background:rgba(15,26,63,.55);
      line-height:1.35;
    }
    .status .big{font-size:14px; font-weight:800; color:var(--text)}
    .status .small{font-size:13px; color:var(--muted)}
    .help{font-size:12.5px; color:var(--muted); margin-top:8px; line-height:1.35}
    .gridWrap{display:flex; flex-wrap:wrap; gap:14px}
    .boardBox{flex:1 1 320px; min-width:300px}
    .boardTitle{display:flex; align-items:center; justify-content:space-between; margin-bottom:8px}
    .boardTitle .label{font-weight:800}
    .legend{display:flex; gap:8px; flex-wrap:wrap; font-size:12px; color:var(--muted)}
    .key{display:flex; align-items:center; gap:6px}
    .sw{width:12px; height:12px; border-radius:4px; border:1px solid #22306a}
    .sw.ship{background:#8aa0ff}
    .sw.hit{background:var(--bad)}
    .sw.miss{background:#7a8bbf}
    .sw.sunk{background:var(--sunk)}
    .sw.water{background:var(--water)}
    canvas{
      width:100%; max-width:420px; aspect-ratio:1/1; height:auto;
      border-radius:12px; border:1px solid #22306a; background:rgba(10,14,28,.5);
      touch-action: none;
    }
    .turnBadge{
      padding:6px 10px; border-radius:999px; border:1px solid #2b3a85;
      background:rgba(106,169,255,.15); color:var(--text); font-weight:900; font-size:12px;
    }
    .shipTray{
      margin-top:10px;
      border:1px solid #22306a; border-radius:12px;
      background:rgba(15,26,63,.35);
      padding:10px;
    }
    .shipTrayTitle{
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom:8px; color:var(--muted); font-size:12.5px; font-weight:900;
    }
    .shipList{display:flex; flex-direction:column; gap:8px}
    .shipItem{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px;
      border:1px solid #2b3a85; border-radius:10px;
      background:rgba(26,37,82,.45);
      cursor:grab; user-select:none; outline:none;
    }
    .shipItem:active{cursor:grabbing}
    .shipItem[aria-disabled="true"]{opacity:.45; cursor:not-allowed}
    .shipItem.selected{
      border-color: rgba(106,169,255,.95);
      box-shadow: 0 0 0 2px rgba(106,169,255,.18) inset;
      background: rgba(106,169,255,.12);
    }
    .shipBar{display:inline-flex; gap:4px; align-items:center;}
    .seg{
      width:12px; height:12px; border-radius:4px;
      background:rgba(138,160,255,.9);
      border:1px solid rgba(34,48,106,.95);
    }
    .hint{
      font-size:12px; color:var(--muted);
      margin-top:8px; line-height:1.35;
    }
    .warn{color:var(--warn)}
    .kbd{
      display:inline-block;
      padding:1px 6px;
      border:1px solid #2b3a85; border-bottom-width:2px;
      border-radius:7px;
      background:rgba(26,37,82,.55);
      font-weight:900; font-size:12px;
      margin:0 2px; color:var(--text);
    }
  </style>
</head>
<body>
<header>
  <h1>⚓ Battleship</h1>
  <div class="pill">
    <span>Mode:</span> <strong id="modeLabel">Vs Computer</strong>
    <span class="turnBadge" id="turnLabel">—</span>
  </div>
</header>

<div class="wrap">
  <div class="row">
    <div class="panel controls">
      <h2>Game Setup</h2>

      <div class="line">
        <select id="mode">
          <option value="cpu" selected>Vs Computer</option>
          <option value="local">Local 2-Player (hotseat)</option>
        </select>
        <button id="newGameBtn">New Game</button>
      </div>

      <div class="line">
        <button id="rotateBtn" title="Rotate ship placement (R / Q / E)">Rotate</button>
        <button id="randomBtn" title="Randomly place remaining ships">Random Place</button>
        <button id="clearBtn" title="Clear placements">Clear</button>
      </div>

      <div class="line">
        <button id="readyBtn" disabled>Ready / Next</button>
      </div>

      <div class="status">
        <div class="big" id="statusTitle">Place your ships</div>
        <div class="small" id="statusText">Drag a ship or tap to select, then place on your board.</div>
      </div>

      <div class="shipTray">
        <div class="shipTrayTitle">
          <span>Ships</span>
          <span id="orientLabel">Orientation: Horizontal</span>
        </div>

        <div class="shipList" id="shipList"></div>

        <div class="hint">
          Desktop: drag a ship onto the board. Right-click the board to rotate while hovering.<br/>
          Touch: tap a ship to select, move finger on board for preview, tap to drop.<br/>
          Rotate: <span class="kbd">Q</span> / <span class="kbd">E</span> (or <span class="kbd">R</span>).<br/>
          During battle: placements are hidden (fog of war).
        </div>
      </div>

      <div class="help">
        <div><strong>Turns:</strong> Hit = shoot again. Miss = turn switches.</div>
      </div>
    </div>

    <div class="panel boards">
      <h2>Boards</h2>
      <div class="gridWrap">
        <div class="boardBox">
          <div class="boardTitle">
            <div class="label" id="ownLabel">Your Fleet</div>
            <div class="legend">
              <span class="key"><span class="sw water"></span>Water</span>
              <span class="key"><span class="sw ship"></span>Ship</span>
              <span class="key"><span class="sw hit"></span>Hit</span>
              <span class="key"><span class="sw miss"></span>Miss</span>
              <span class="key"><span class="sw sunk"></span>Sunk</span>
            </div>
          </div>
          <canvas id="ownCanvas" width="420" height="420"></canvas>
        </div>

        <div class="boardBox">
          <div class="boardTitle">
            <div class="label" id="enemyLabel">Enemy Waters</div>
            <div class="legend">
              <span class="key"><span class="sw hit"></span>Hit</span>
              <span class="key"><span class="sw miss"></span>Miss</span>
              <span class="key"><span class="sw sunk"></span>Sunk</span>
            </div>
          </div>
          <canvas id="enemyCanvas" width="420" height="420"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== Constants ======
  const SIZE = 10;
  const SHIPS = [
    { key:"carrier",    name:"Carrier",    len:5 },
    { key:"battleship", name:"Battleship", len:4 },
    { key:"cruiser",    name:"Cruiser",    len:3 },
    { key:"submarine",  name:"Submarine",  len:3 },
    { key:"destroyer",  name:"Destroyer",  len:2 },
  ];

  // Shots: 0 none, 1 miss, 2 hit, 3 sunk
  function makeBoard() {
    return {
      ships: Array.from({length: SIZE}, () => Array(SIZE).fill(0)),
      shots: Array.from({length: SIZE}, () => Array(SIZE).fill(0)),
      shipsPlaced: [] // [{key,name,len,cells:[{r,c}]}]
    };
  }

  // ====== UI ======
  const modeSel     = document.getElementById("mode");
  const modeLabel   = document.getElementById("modeLabel");
  const turnLabel   = document.getElementById("turnLabel");
  const ownLabel    = document.getElementById("ownLabel");
  const enemyLabel  = document.getElementById("enemyLabel");

  const ownCanvas   = document.getElementById("ownCanvas");
  const enemyCanvas = document.getElementById("enemyCanvas");
  const octx        = ownCanvas.getContext("2d");
  const ectx        = enemyCanvas.getContext("2d");

  const rotateBtn   = document.getElementById("rotateBtn");
  const randomBtn   = document.getElementById("randomBtn");
  const clearBtn    = document.getElementById("clearBtn");
  const readyBtn    = document.getElementById("readyBtn");
  const newGameBtn  = document.getElementById("newGameBtn");

  const statusTitle = document.getElementById("statusTitle");
  const statusText  = document.getElementById("statusText");
  const shipListEl  = document.getElementById("shipList");
  const orientLabel = document.getElementById("orientLabel");

  // ====== Sound (Web Audio, no files) ======
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
  }
  function beep(freq, durMs, type="sine", gain=0.05){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + durMs/1000);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + durMs/1000);
  }
  const SFX = {
    miss(){ ensureAudio(); beep(200,120,"triangle",0.05); },
    hit(){ ensureAudio(); beep(520,90,"square",0.05); beep(680,120,"square",0.04); },
    sunk(){ ensureAudio(); beep(420,110,"sawtooth",0.06); beep(320,160,"sawtooth",0.05); beep(240,220,"sawtooth",0.04); },
    win(){ ensureAudio(); beep(660,130,"sine",0.05); beep(880,170,"sine",0.05); beep(990,220,"sine",0.05); },
    lose(){ ensureAudio(); beep(330,200,"sine",0.05); beep(220,260,"sine",0.05); }
  };

  // ====== Game State ======
  const State = {
    mode: "cpu",      // cpu | local
    phase: "p1_place",// p1_place | p2_place | battle | pass | gameover
    orientation: "H", // H | V
    turn: "p1",       // p1 | p2
    passTarget: null, // p1 | p2
    p1: makeBoard(),
    p2: makeBoard(),
    // placement input state:
    draggingShipKey: null,     // HTML5 drag
    selectedShipKey: null,     // tap-to-select
    hoverCells: null,
    hoverOk: true,
    lastHoverAnchor: null,     // {r,c} for snap-to-grid hover
    // Smarter CPU AI
    cpuAI: {
      huntList: [],
      targetQueue: [],
      hitChain: [],
      lockedAxis: null,
    }
  };

  // ====== Helpers ======
  function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }
  function setStatus(title, text){ statusTitle.textContent = title; statusText.textContent = text; }
  function setTurnBadge(text){ turnLabel.textContent = text; }
  function shipByKey(key){ return SHIPS.find(s => s.key===key) || null; }
  function hasShipPlaced(board, shipKey){ return board.shipsPlaced.some(s => s.key === shipKey); }

  function cellsForPlacement(r,c,len,orient){
    const out = [];
    for(let i=0;i<len;i++){
      const rr = r + (orient==="V" ? i : 0);
      const cc = c + (orient==="H" ? i : 0);
      if(!inBounds(rr,cc)) return null;
      out.push({r:rr,c:cc});
    }
    return out;
  }

  function canPlace(board, cells){
    for (const {r,c} of cells){
      if(board.ships[r][c] === 1) return false;
      for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
          const rr=r+dr, cc=c+dc;
          if(inBounds(rr,cc) && board.ships[rr][cc]===1) return false;
        }
      }
    }
    return true;
  }

  function placeShip(board, ship, cells){
    for(const {r,c} of cells) board.ships[r][c]=1;
    board.shipsPlaced.push({ ...ship, cells: cells.map(p=>({r:p.r,c:p.c})) });
  }

  function clearPlacements(board){
    board.ships = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    board.shipsPlaced = [];
  }

  function countRemainingShipCells(board){
    let n=0;
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(board.ships[r][c]===1 && board.shots[r][c]!==2 && board.shots[r][c]!==3) n++;
      }
    }
    return n;
  }

  function findShipByCell(defender, r, c){
    return defender.shipsPlaced.find(ship => ship.cells.some(p => p.r===r && p.c===c)) || null;
  }

  function isShipSunk(defender, ship){
    return ship.cells.every(p => defender.shots[p.r][p.c]===2 || defender.shots[p.r][p.c]===3);
  }

  function markShipSunk(defender, ship){
    for(const p of ship.cells){
      defender.shots[p.r][p.c] = 3;
    }
  }

  function fireAt(defender, r, c){
    if(defender.shots[r][c] !== 0) return { ok:false, msg:"Already fired there." };
    if(defender.ships[r][c] === 1){
      defender.shots[r][c] = 2;
      const ship = findShipByCell(defender, r, c);
      let sunkName = null;
      if(ship && isShipSunk(defender, ship)){
        markShipSunk(defender, ship);
        sunkName = ship.name;
      }
      return { ok:true, hit:true, sunk:sunkName };
    } else {
      defender.shots[r][c] = 1;
      return { ok:true, hit:false, sunk:null };
    }
  }

  function randomPlaceAllRemaining(board){
    for(const ship of SHIPS){
      if(hasShipPlaced(board, ship.key)) continue;
      let placed=false;
      for(let tries=0; tries<900 && !placed; tries++){
        const orient = Math.random() < 0.5 ? "H" : "V";
        const r = Math.floor(Math.random()*SIZE);
        const c = Math.floor(Math.random()*SIZE);
        const cells = cellsForPlacement(r,c,ship.len,orient);
        if(!cells) continue;
        if(!canPlace(board,cells)) continue;
        placeShip(board, ship, cells);
        placed=true;
      }
      if(!placed){
        clearPlacements(board);
        for(const s of SHIPS){
          let ok=false;
          for(let tries=0; tries<1500 && !ok; tries++){
            const orient = Math.random() < 0.5 ? "H" : "V";
            const r = Math.floor(Math.random()*SIZE);
            const c = Math.floor(Math.random()*SIZE);
            const cells = cellsForPlacement(r,c,s.len,orient);
            if(!cells) continue;
            if(!canPlace(board,cells)) continue;
            placeShip(board, s, cells);
            ok=true;
          }
        }
        return;
      }
    }
  }

  // ====== Snap-to-grid mapping ======
  function getRCFromCanvas(canvas, evt){
    const rect = canvas.getBoundingClientRect();
    const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
    const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top)  * (canvas.height/ rect.height);
    const c = Math.floor(x / (canvas.width / SIZE));
    const r = Math.floor(y / (canvas.height/ SIZE));
    if(!inBounds(r,c)) return null;
    return {r,c};
  }

  // ====== Rendering ======
  function drawSunkLabels(ctx, board){
    const w = ctx.canvas.width;
    const cell = w / SIZE;

    ctx.save();
    ctx.font = "800 11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for(const ship of board.shipsPlaced){
      const sunk = ship.cells.every(p => board.shots[p.r][p.c]===3);
      if(!sunk) continue;

      const avgR = ship.cells.reduce((a,p)=>a+p.r,0)/ship.cells.length;
      const avgC = ship.cells.reduce((a,p)=>a+p.c,0)/ship.cells.length;

      const x = (avgC + 0.5) * cell;
      const y = (avgR + 0.5) * cell;

      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillText(ship.name, x+1, y+1);
      ctx.fillStyle = "rgba(255,183,3,.98)";
      ctx.fillText(ship.name, x, y);
    }
    ctx.restore();
  }

  function drawBoard(ctx, board, showShips, hoverCells=null, hoverOk=true){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    const cell = w / SIZE;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(15,26,63,.85)";
    ctx.fillRect(0,0,w,h);

    // hover ghost (placement only)
    if(hoverCells){
      ctx.fillStyle = hoverOk ? "rgba(106,169,255,.22)" : "rgba(255,92,122,.18)";
      for(const {r,c} of hoverCells){
        ctx.fillRect(c*cell, r*cell, cell, cell);
      }
    }

    // ships (only in placement; NEVER in battle)
    if(showShips){
      ctx.fillStyle = "rgba(138,160,255,.85)";
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          if(board.ships[r][c]===1){
            ctx.fillRect(c*cell+1, r*cell+1, cell-2, cell-2);
          }
        }
      }
    }

    // shots
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const s = board.shots[r][c];
        if(s===1){
          ctx.fillStyle = "rgba(122,139,191,.95)";
          ctx.beginPath();
          ctx.arc(c*cell+cell/2, r*cell+cell/2, cell*0.18, 0, Math.PI*2);
          ctx.fill();
        } else if(s===2){
          ctx.fillStyle = "rgba(255,92,122,.95)";
          ctx.beginPath();
          ctx.arc(c*cell+cell/2, r*cell+cell/2, cell*0.22, 0, Math.PI*2);
          ctx.fill();
        } else if(s===3){
          ctx.fillStyle = "rgba(255,183,3,.95)";
          ctx.beginPath();
          ctx.arc(c*cell+cell/2, r*cell+cell/2, cell*0.24, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,183,3,.55)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(c*cell+cell*0.2, r*cell+cell*0.2);
          ctx.lineTo(c*cell+cell*0.8, r*cell+cell*0.8);
          ctx.moveTo(c*cell+cell*0.8, r*cell+cell*0.2);
          ctx.lineTo(c*cell+cell*0.2, r*cell+cell*0.8);
          ctx.stroke();
        }
      }
    }

    // labels for sunk ships
    drawSunkLabels(ctx, board);

    // grid
    ctx.strokeStyle = "rgba(43,54,102,1)";
    ctx.lineWidth = 1;
    for(let i=0;i<=SIZE;i++){
      const p = i*cell;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(w,p); ctx.stroke();
    }
  }

  function render(){
    const {mode, phase, turn} = State;
    modeLabel.textContent = mode === "cpu" ? "Vs Computer" : "Local 2-Player";
    orientLabel.textContent = "Orientation: " + (State.orientation==="H" ? "Horizontal" : "Vertical");

    // === Ship visibility rules ===
    // Placement phase: show your own ships for placement.
    // Battle phase: HIDE ALL ship placements (fog of war).
    // Pass: hide everything.
    // Gameover: show everything (change if you want fog on gameover too).
    let showP1Ships=false, showP2Ships=false;
    if(phase==="p1_place"){ showP1Ships=true; showP2Ships=false; }
    if(phase==="p2_place"){ showP1Ships=false; showP2Ships=true; }
    if(phase==="pass"){ showP1Ships=false; showP2Ships=false; }
    if(phase==="battle"){ showP1Ships=false; showP2Ships=false; } // <-- Fog of war during gameplay
    if(phase==="gameover"){ showP1Ships=true; showP2Ships=true; }

    // labels
    if(mode==="cpu"){
      ownLabel.textContent = "Your Board";
      enemyLabel.textContent = "Enemy Board";
    } else {
      ownLabel.textContent = (phase==="battle" && turn==="p2") ? "Player 2 Board" : "Player 1 Board";
      enemyLabel.textContent = (phase==="battle" && turn==="p2") ? "Player 1 Board" : "Player 2 Board";
    }

    // map canvases to current player view
    let ownBoard, enemyBoard;
    if(phase==="p1_place" || (phase==="pass" && State.passTarget==="p1")){
      ownBoard = State.p1; enemyBoard = State.p2;
    } else if(phase==="p2_place" || (phase==="pass" && State.passTarget==="p2")){
      ownBoard = State.p2; enemyBoard = State.p1;
    } else if(phase==="battle"){
      ownBoard = (turn==="p1") ? State.p1 : State.p2;
      enemyBoard = (turn==="p1") ? State.p2 : State.p1;
    } else {
      ownBoard = State.p1; enemyBoard = State.p2;
    }

    const placing = (phase==="p1_place" || phase==="p2_place");

    drawBoard(
      octx,
      ownBoard,
      (ownBoard===State.p1 ? showP1Ships : showP2Ships),
      placing ? State.hoverCells : null,
      State.hoverOk
    );
    drawBoard(
      ectx,
      enemyBoard,
      (enemyBoard===State.p1 ? showP1Ships : showP2Ships),
      null,
      true
    );

    // controls
    rotateBtn.disabled = !placing;
    randomBtn.disabled = !placing;
    clearBtn.disabled  = !placing;

    // ready
    const curPlaceBoard = (phase==="p1_place") ? State.p1 : State.p2;
    if(phase==="p1_place") readyBtn.disabled = (curPlaceBoard.shipsPlaced.length !== SHIPS.length);
    else if(phase==="p2_place") readyBtn.disabled = (curPlaceBoard.shipsPlaced.length !== SHIPS.length);
    else if(phase==="pass") readyBtn.disabled = false;
    else readyBtn.disabled = true;

    // turn badge
    if(phase==="battle"){
      setTurnBadge(mode==="cpu"
        ? (turn==="p1" ? "Your turn" : "Computer turn")
        : (turn==="p1" ? "Player 1 turn" : "Player 2 turn"));
    } else if(phase==="p1_place"){
      setTurnBadge(mode==="cpu" ? "Setup" : "P1 setup");
    } else if(phase==="p2_place"){
      setTurnBadge("P2 setup");
    } else if(phase==="pass"){
      setTurnBadge("Pass device");
    } else if(phase==="gameover"){
      setTurnBadge("Game over");
    } else {
      setTurnBadge("—");
    }

    renderShipTray();
  }

  // ====== Ship tray ======
  function renderShipTray(){
    const placing = (State.phase==="p1_place" || State.phase==="p2_place");
    const board = (State.phase==="p1_place") ? State.p1 : (State.phase==="p2_place" ? State.p2 : null);

    shipListEl.innerHTML = "";
    for(const ship of SHIPS){
      const placed = board ? hasShipPlaced(board, ship.key) : false;

      const item = document.createElement("div");
      item.className = "shipItem";
      if(State.selectedShipKey === ship.key) item.classList.add("selected");
      item.setAttribute("draggable", (placing && !placed) ? "true" : "false");
      item.setAttribute("aria-disabled", (!placing || placed) ? "true" : "false");
      item.dataset.shipKey = ship.key;
      item.tabIndex = 0;

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.flexDirection = "column";
      left.style.gap = "3px";

      const name = document.createElement("div");
      name.textContent = `${ship.name} (${ship.len})` + (placed ? " ✓" : "");
      name.style.fontWeight = "900";
      name.style.fontSize = "13px";

      const bar = document.createElement("div");
      bar.className = "shipBar";
      for(let i=0;i<ship.len;i++){
        const seg = document.createElement("span");
        seg.className = "seg";
        bar.appendChild(seg);
      }

      left.appendChild(name);
      left.appendChild(bar);

      const right = document.createElement("div");
      right.style.color = "var(--muted)";
      right.style.fontSize = "12px";
      right.textContent = (!placing ? "" : (placed ? "Placed" : (State.selectedShipKey===ship.key ? "Selected" : "Drag / Tap")));

      item.appendChild(left);
      item.appendChild(right);

      item.addEventListener("dragstart", (e)=>{
        if(!placing || placed) { e.preventDefault(); return; }
        State.draggingShipKey = ship.key;
        e.dataTransfer.setData("text/plain", ship.key);
        e.dataTransfer.effectAllowed = "move";
      });
      item.addEventListener("dragend", ()=>{
        State.draggingShipKey = null;
        State.hoverCells = null;
        State.hoverOk = true;
        State.lastHoverAnchor = null;
        render();
      });

      // Tap-to-select (touch-friendly)
      item.addEventListener("pointerdown", (e)=>{
        if(!placing || placed) return;
        ensureAudio();
        State.selectedShipKey = (State.selectedShipKey === ship.key) ? null : ship.key;
        State.draggingShipKey = null;
        State.hoverCells = null;
        State.hoverOk = true;
        State.lastHoverAnchor = null;
        updatePlacementStatus();
        render();
        e.preventDefault();
      });

      shipListEl.appendChild(item);
    }
  }

  // ====== Phase transitions ======
  function placingBoard(){ return (State.phase==="p1_place") ? State.p1 : State.p2; }

  function startNewGame(){
    State.mode = modeSel.value;
    State.phase = "p1_place";
    State.turn = "p1";
    State.passTarget = null;
    State.orientation = "H";
    State.p1 = makeBoard();
    State.p2 = makeBoard();
    State.draggingShipKey = null;
    State.selectedShipKey = null;
    State.hoverCells = null;
    State.hoverOk = true;
    State.lastHoverAnchor = null;

    resetCpuAI();

    if(State.mode==="cpu"){
      randomPlaceAllRemaining(State.p2);
      setStatus("Place your ships", "Drag a ship or tap to select, then place on your board.");
    } else {
      setStatus("Player 1: Place ships", "Player 1 places ships, then press Ready / Next.");
    }
    updatePlacementStatus();
    render();
  }

  function goToPass(target){
    State.phase = "pass";
    State.passTarget = target;
    State.hoverCells = null;
    State.lastHoverAnchor = null;
    setStatus("Pass the device", target==="p1"
      ? "Give the device to Player 1. Press Ready / Next when ready."
      : "Give the device to Player 2. Press Ready / Next when ready."
    );
    render();
  }

  function beginBattle(){
    State.phase = "battle";
    State.turn = "p1";
    State.selectedShipKey = null;
    State.hoverCells = null;
    State.lastHoverAnchor = null;
    resetCpuAI();
    setStatus("Battle started", State.mode==="cpu"
      ? "Click the enemy board (right) to fire. Hit = go again."
      : "Player 1 goes first. Click Player 2's board (right) to fire. Hit = go again."
    );
    render();
  }

  function endGame(winner){
    State.phase = "gameover";
    const msg = (State.mode==="cpu")
      ? (winner==="p1" ? "You sank all enemy ships!" : "Computer sank all your ships.")
      : (winner==="p1" ? "Player 1 wins!" : "Player 2 wins!");
    setStatus("Game Over", msg + " Press New Game to play again.");
    if(State.mode==="cpu"){
      if(winner==="p1") SFX.win(); else SFX.lose();
    } else {
      SFX.win();
    }
    render();
  }

  // ====== Placement status + hover recompute ======
  function updatePlacementStatus(){
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;

    const board = placingBoard();
    const remaining = SHIPS.filter(s => !hasShipPlaced(board, s.key));

    if(remaining.length===0){
      setStatus("All ships placed", "Press Ready / Next to continue.");
      return;
    }

    const selected = State.selectedShipKey ? shipByKey(State.selectedShipKey) : null;
    const who = (State.phase==="p1_place")
      ? (State.mode==="cpu" ? "Place your ships" : "Player 1: Place ships")
      : "Player 2: Place ships";

    if(selected){
      setStatus(
        who,
        `Selected: ${selected.name} (${selected.len}). Move over board for preview, tap/click to place. Rotate: Q/E/R.`
      );
    } else {
      setStatus(
        who,
        `Pick a ship (drag or tap). Orientation: ${State.orientation==="H" ? "Horizontal" : "Vertical"}. Remaining: ${remaining.map(s=>s.name).join(", ")}`
      );
    }
  }

  function recomputeHover(){
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    if(!State.lastHoverAnchor) return;

    const key = State.draggingShipKey || State.selectedShipKey;
    const ship = shipByKey(key);
    const board = placingBoard();

    if(!ship || hasShipPlaced(board, ship.key)){
      State.hoverCells = null;
      State.hoverOk = false;
      render();
      return;
    }

    const cells = cellsForPlacement(State.lastHoverAnchor.r, State.lastHoverAnchor.c, ship.len, State.orientation);
    State.hoverCells = cells;
    State.hoverOk = !!cells && canPlace(board, cells);
    render();
  }

  // ====== Rotation (Q/E/R + button + right-click) ======
  function rotate(){
    State.orientation = (State.orientation==="H") ? "V" : "H";
    updatePlacementStatus();
    recomputeHover();
    render();
  }

  rotateBtn.addEventListener("click", ()=>{ ensureAudio(); rotate(); });

  document.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if(k==="r" || k==="q" || k==="e"){
      ensureAudio();
      rotate();
    }
  });

  ownCanvas.addEventListener("contextmenu", (e)=>{
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    e.preventDefault();
    ensureAudio();
    rotate();
  });

  // ====== Desktop drag hover/drop ======
  function handleDragHover(evt){
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    evt.preventDefault();
    const pos = getRCFromCanvas(ownCanvas, evt);
    if(!pos) return;

    State.lastHoverAnchor = pos;

    const key = State.draggingShipKey || evt.dataTransfer.getData("text/plain");
    const ship = shipByKey(key);
    const board = placingBoard();

    if(!ship || hasShipPlaced(board, key)){
      State.hoverCells = null;
      State.hoverOk = false;
      render();
      return;
    }

    const cells = cellsForPlacement(pos.r, pos.c, ship.len, State.orientation);
    State.hoverCells = cells;
    State.hoverOk = !!cells && canPlace(board, cells);
    render();
  }

  ownCanvas.addEventListener("dragover", handleDragHover);
  ownCanvas.addEventListener("dragenter", handleDragHover);
  ownCanvas.addEventListener("dragleave", ()=>{
    State.hoverCells = null;
    State.hoverOk = true;
    State.lastHoverAnchor = null;
    render();
  });

  function tryPlaceAt(r,c, shipKey){
    const board = placingBoard();
    const ship = shipByKey(shipKey);
    if(!ship) return {ok:false, msg:"Unknown ship."};
    if(hasShipPlaced(board, ship.key)) return {ok:false, msg:"That ship is already placed."};

    const cells = cellsForPlacement(r,c,ship.len,State.orientation);
    if(!cells) return {ok:false, msg:"Out of bounds."};
    if(!canPlace(board,cells)) return {ok:false, msg:"Ships can't overlap or touch."};

    placeShip(board, ship, cells);
    return {ok:true, msg:`Placed ${ship.name}.`};
  }

  ownCanvas.addEventListener("drop", (evt)=>{
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    evt.preventDefault();
    ensureAudio();

    const pos = getRCFromCanvas(ownCanvas, evt);
    if(!pos) return;

    const shipKey = State.draggingShipKey || evt.dataTransfer.getData("text/plain");
    const res = tryPlaceAt(pos.r, pos.c, shipKey);

    if(!res.ok){
      setStatus("Can't place there", res.msg);
    } else {
      State.selectedShipKey = null;
      updatePlacementStatus();
    }

    State.draggingShipKey = null;
    State.hoverCells = null;
    State.hoverOk = true;
    State.lastHoverAnchor = null;
    render();
  });

  // ====== Touch support (select + snap hover + tap place) ======
  ownCanvas.addEventListener("pointermove", (evt)=>{
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    const key = State.selectedShipKey;
    if(!key) return;

    const pos = getRCFromCanvas(ownCanvas, evt);
    if(!pos) return;
    State.lastHoverAnchor = pos;

    const ship = shipByKey(key);
    const board = placingBoard();
    if(!ship || hasShipPlaced(board, key)){
      State.hoverCells = null;
      State.hoverOk = false;
      render();
      return;
    }

    const cells = cellsForPlacement(pos.r, pos.c, ship.len, State.orientation);
    State.hoverCells = cells;
    State.hoverOk = !!cells && canPlace(board, cells);
    render();
  });

  ownCanvas.addEventListener("pointerdown", (evt)=>{
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    ensureAudio();

    // Ignore if desktop drag is active
    if(State.draggingShipKey) return;

    const key = State.selectedShipKey;
    if(!key) return;

    const pos = getRCFromCanvas(ownCanvas, evt);
    if(!pos) return;

    const res = tryPlaceAt(pos.r, pos.c, key);
    if(!res.ok){
      setStatus("Can't place there", res.msg);
    } else {
      State.selectedShipKey = null;
      updatePlacementStatus();
    }

    State.hoverCells = null;
    State.hoverOk = true;
    State.lastHoverAnchor = null;
    render();
    evt.preventDefault();
  });

  ownCanvas.addEventListener("pointerleave", ()=>{
    State.hoverCells = null;
    State.hoverOk = true;
    State.lastHoverAnchor = null;
    render();
  });

  // ====== Buttons ======
  randomBtn.addEventListener("click", ()=>{
    ensureAudio();
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    randomPlaceAllRemaining(placingBoard());
    State.selectedShipKey = null;
    State.hoverCells = null;
    State.lastHoverAnchor = null;
    updatePlacementStatus();
    render();
  });

  clearBtn.addEventListener("click", ()=>{
    ensureAudio();
    if(!(State.phase==="p1_place" || State.phase==="p2_place")) return;
    clearPlacements(placingBoard());
    State.selectedShipKey = null;
    State.hoverCells = null;
    State.lastHoverAnchor = null;
    updatePlacementStatus();
    render();
  });

  newGameBtn.addEventListener("click", ()=>{ ensureAudio(); startNewGame(); });
  modeSel.addEventListener("change", ()=>{ ensureAudio(); startNewGame(); });

  // ====== Battle rules: Hit = extra turn, Miss = switch turn ======
  function currentDefender(){
    return (State.turn==="p1") ? State.p2 : State.p1;
  }

  function afterShot(res){
    const def = currentDefender();

    // win check
    if(countRemainingShipCells(def)===0){
      endGame(State.turn);
      return;
    }

    // HIT => same attacker shoots again
    if(res.hit){
      if(State.mode==="cpu"){
        if(State.turn==="p1"){
          setStatus(res.sunk ? "Sunk! Go again" : "Hit! Go again", "You hit — take another shot.");
          render();
        } else {
          setStatus(res.sunk ? "Computer sunk one! Again…" : "Computer hit! Again…", "Computer gets another shot.");
          render();
          setTimeout(cpuMove, 450);
        }
      } else {
        setStatus(res.sunk ? "Sunk! Go again" : "Hit! Go again", "You hit — take another shot.");
        render();
      }
      return;
    }

    // MISS => switch turn
    if(State.mode==="cpu"){
      if(State.turn==="p1"){
        State.turn="p2";
        render();
        setStatus("Computer turn", "You missed — computer is shooting.");
        setTimeout(cpuMove, 450);
      } else {
        State.turn="p1";
        setStatus("Your turn", "Computer missed — your shot.");
        render();
      }
    } else {
      const next = (State.turn==="p1") ? "p2" : "p1";
      State.turn = next;
      goToPass(next);
    }
  }

  function battleFire(r,c){
    const defender = currentDefender();
    const res = fireAt(defender, r, c);
    if(!res.ok){
      setStatus("Pick another target", res.msg);
      return;
    }

    if(res.hit){
      if(res.sunk){
        setStatus("Hit — Sunk!", `You sunk the ${res.sunk}! (Shoot again)`);
        SFX.sunk();
      } else {
        setStatus("Hit!", "Direct hit. (Shoot again)");
        SFX.hit();
      }
    } else {
      setStatus("Miss", "Splash… you missed. (Turn ends)");
      SFX.miss();
    }

    render();
    afterShot(res);
  }

  enemyCanvas.addEventListener("click", (evt)=>{
    ensureAudio();
    if(State.phase!=="battle") return;
    if(State.mode==="cpu" && State.turn!=="p1") return;
    const pos = getRCFromCanvas(enemyCanvas, evt);
    if(!pos) return;
    battleFire(pos.r, pos.c);
  });

  // ====== Ready / Next ======
  readyBtn.addEventListener("click", ()=>{
    ensureAudio();

    if(State.phase==="p1_place"){
      if(State.mode==="cpu"){
        beginBattle();
      } else {
        goToPass("p2");
      }
      return;
    }

    if(State.phase==="p2_place"){
      if(State.p2.shipsPlaced.length === SHIPS.length){
        goToPass("p1");
      }
      return;
    }

    if(State.phase==="pass" && State.mode==="local"){
      if(State.passTarget==="p2"){
        if(State.p2.shipsPlaced.length !== SHIPS.length){
          State.phase="p2_place";
          setStatus("Player 2: Place ships", "Place ships, then press Ready / Next.");
          updatePlacementStatus();
          render();
        } else {
          beginBattle();
        }
        return;
      }

      if(State.passTarget==="p1"){
        // Return to battle view for current player
        State.phase="battle";
        setStatus(State.turn==="p1" ? "Player 1 turn" : "Player 2 turn", "Fire on the enemy board. Hit = go again.");
        render();
        return;
      }
    }
  });

  // ====== Smarter CPU AI (hunt/target with parity + line-lock) ======
  function resetCpuAI(){
    const ai = State.cpuAI;
    ai.huntList = makeParityHuntList();
    shuffle(ai.huntList);
    ai.targetQueue = [];
    ai.hitChain = [];
    ai.lockedAxis = null;
  }

  function makeParityHuntList(){
    const list = [];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if((r+c)%2===0) list.push({r,c});
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if((r+c)%2===1) list.push({r,c});
    return list;
  }

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }

  function shotsOpen(board, r,c){
    return inBounds(r,c) && board.shots[r][c]===0;
  }

  function lineExtensions(hitChain, axis){
    if(axis==="H"){
      const r = hitChain[0].r;
      const cols = hitChain.map(p=>p.c).sort((a,b)=>a-b);
      return [{r, c: cols[0]-1}, {r, c: cols[cols.length-1]+1}];
    } else {
      const c = hitChain[0].c;
      const rows = hitChain.map(p=>p.r).sort((a,b)=>a-b);
      return [{r: rows[0]-1, c}, {r: rows[rows.length-1]+1, c}];
    }
  }

  function inferAxisFromHits(hitChain){
    if(hitChain.length<2) return null;
    for(let i=0;i<hitChain.length;i++){
      for(let j=i+1;j<hitChain.length;j++){
        if(hitChain[i].r===hitChain[j].r) return "H";
        if(hitChain[i].c===hitChain[j].c) return "V";
      }
    }
    return null;
  }

  function queueNeighbors(r,c){
    const neigh = [{r:r-1,c},{r:r+1,c},{r,c:c-1},{r,c:c+1}].filter(p=>inBounds(p.r,p.c));
    for(const p of neigh) State.cpuAI.targetQueue.unshift(p);
  }

  function cpuPickTarget(){
    const ai = State.cpuAI;
    const player = State.p1;

    if(ai.hitChain.length>=2 && ai.lockedAxis){
      const candidates = lineExtensions(ai.hitChain, ai.lockedAxis);
      for(const t of candidates){
        if(shotsOpen(player, t.r, t.c)) return t;
      }
    }

    while(ai.targetQueue.length){
      const t = ai.targetQueue.shift();
      if(shotsOpen(player, t.r, t.c)) return t;
    }

    while(ai.huntList.length){
      const t = ai.huntList.shift();
      if(shotsOpen(player, t.r, t.c)) return t;
    }

    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
      if(player.shots[r][c]===0) return {r,c};
    }
    return null;
  }

  function cpuOnHit(r,c, sunkName){
    const ai = State.cpuAI;
    if(sunkName){
      ai.hitChain = [];
      ai.lockedAxis = null;
      ai.targetQueue = [];
      return;
    }
    ai.hitChain.push({r,c});
    const axis = inferAxisFromHits(ai.hitChain);
    if(axis) ai.lockedAxis = axis;
    if(!ai.lockedAxis) queueNeighbors(r,c);
  }

  function cpuMove(){
    if(State.phase!=="battle" || State.turn!=="p2") return;

    const target = cpuPickTarget();
    if(!target){
      State.turn="p1";
      setStatus("Your turn", "Computer stuck — your shot.");
      render();
      return;
    }

    const res = fireAt(State.p1, target.r, target.c);

    if(res.hit){
      cpuOnHit(target.r, target.c, res.sunk);
      if(res.sunk){
        setStatus("Computer hit — sunk!", `Computer sunk your ${res.sunk}! (It shoots again)`);
        SFX.sunk();
      } else {
        setStatus("Computer hit!", "Computer scored a hit. (It shoots again)");
        SFX.hit();
      }
    } else {
      setStatus("Computer missed", "Computer missed. Your turn.");
      SFX.miss();
    }

    render();

    if(countRemainingShipCells(State.p1)===0){
      endGame("p2");
      return;
    }

    // Extra turn rule: CPU shoots again if it hit; otherwise give turn back
    if(res.hit){
      setTimeout(cpuMove, 450);
    } else {
      State.turn="p1";
      setStatus("Your turn", "Click the enemy board (right) to fire. Hit = go again.");
      render();
    }
  }

  // ====== Start battle ======
  function beginBattle(){
    State.phase = "battle";
    State.turn = "p1";
    State.selectedShipKey = null;
    State.hoverCells = null;
    State.lastHoverAnchor = null;
    resetCpuAI();
    setStatus("Battle started", State.mode==="cpu"
      ? "Click the enemy board (right) to fire. Hit = go again."
      : "Player 1 starts. Hit = go again. Miss = pass device."
    );
    render();
  }

  // Start new game
  startNewGame();
})();
</script>
</body>
</html>
